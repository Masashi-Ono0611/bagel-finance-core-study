;; 6905(computational_gas_price) * 1000(cur_gas_price) = 6905000
;; ceil(6905000) = 10000000 ~= 0.01 TON
int provide_address_gas_consumption() asm "10000000 PUSHINT";

int min_excesses() asm "1000000 PUSHINT";
int gas_deposit(int num_baskets) inline {
    return num_baskets * 3200000 + 1400000;
}
int gas_transfer_notification() asm "10000000 PUSHINT";
int gas_transfer_notification_complete(int num_baskets) inline {
    return num_baskets * 2000000 + 2500000;
}
int gas_burn_notification(int num_baskets) inline {
    return num_baskets * 2100000 + 4000000;
}
int gas_excesses() asm "3000000 PUSHINT";

() mint_tokens(slice to_address, cell jetton_wallet_code, int amount, cell master_msg) impure {
    cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);
    slice to_wallet_address = calculate_jetton_wallet_address(state_init);
    var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(to_wallet_address)
            .store_coins(amount)
            .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
            .store_ref(state_init)
            .store_ref(master_msg);
    send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
}

slice addr_none() asm "b{00} PUSHSLICE";

() swap_dedust_ton (
    int query_id,
    int swap_amount,
    int gas,
    slice dedust_pool_address,
    slice user_address
) impure {
    cell custom_payload = begin_cell()
        .store_slice(user_address)
        .end_cell();
    cell swap_params = begin_cell()
        .store_uint(now() + 5 * 60, 32) ;; deadline:Timestamp
        .store_slice(my_address()) ;; recipient_addr:MsgAddressInt
        .store_slice(addr_none()) ;; referral_addr:MsgAddress
        .store_maybe_ref(custom_payload) ;; fulfill_payload:(Maybe ^Cell)
        .store_maybe_ref(null()) ;; reject_payload:(Maybe ^Cell)
        .end_cell();
    cell body = begin_cell()
        .store_uint(op::dedust_ton_swap(), 32)
        .store_uint(query_id, 64) ;; query_id:int64
        ;; _:SwapStep
        .store_coins(swap_amount)
        .store_slice(dedust_pool_address) ;; pool_addr:MsgAddressInt
        .store_uint(0, 1) ;; kind:SwapKind
        .store_coins(0) ;; limit:Coins
        .store_maybe_ref(null()) ;; next
        .store_ref(swap_params)
        .end_cell();
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(storage::dedust_ton_vault_address)
        .store_coins(swap_amount + gas)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)
        .store_maybe_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}

() mint_index(
    int query_id,
    slice to_address,
    cell jetton_wallet_code,
    int gas,
    int mint_amount
) impure {
    cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);
    slice to_wallet_address = calculate_jetton_wallet_address(state_init);
    cell body = begin_cell()
        .store_uint(op::internal_transfer(), 32)
        .store_uint(query_id, 64)
        .store_coins(mint_amount)
        .store_slice(my_address())
        .store_slice(to_address)
        .store_coins(0)
        .store_uint(0, 1)
        .end_cell();
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to_wallet_address)
        .store_coins(gas)
        .store_uint(7, 107)
        .store_ref(state_init)
        .store_maybe_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}

() send_jetton(
    int query_id,
    slice jetton_wallet_address,
    int gas,
    int jetton_amount,
    slice to_address
) impure {
    cell body = begin_cell()
        .store_uint(op::transfer(), 32)
        .store_uint(query_id, 64)
        .store_coins(jetton_amount)
        .store_slice(to_address)
        .store_slice(to_address)
        .store_uint(0, 1)
        .store_coins(0)
        .store_uint(0, 1)
        .end_cell();
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jetton_wallet_address)
        .store_coins(gas)
        .store_uint(1, 107)
        .store_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}

() swap_dedust_jetton (
    int query_id,
    slice jetton_wallet_address,
    int gas,
    int swap_amount,
    slice dedust_vault_address,
    int forward_fee,
    slice dedust_pool_address,
    slice user_address
) impure {
    cell swap_params = begin_cell()
        .store_uint(now() + 60 * 5, 32) ;; deadline:Timestamp
        .store_slice(user_address) ;; recipient_addr:MsgAddressInt
        .store_slice(addr_none()) ;; referral_addr:MsgAddress
        .store_maybe_ref(null()) ;; fulfill_payload:(Maybe ^Cell)
        .store_maybe_ref(null()) ;; reject_payload:(Maybe ^Cell)
        .end_cell();
    cell forward_payload = begin_cell()
        .store_uint(op::dedust_jetton_swap(), 32)
        .store_slice(dedust_pool_address) ;; pool_addr:MsgAddressInt
        .store_uint(0, 1) ;; kind:SwapKind
        .store_coins(0) ;; limit:Coins
        .store_maybe_ref(null()) ;; next
        .store_ref(swap_params)
        .end_cell();
    cell body = begin_cell()
        .store_uint(op::transfer(), 32)
        .store_uint(query_id, 64)
        .store_coins(swap_amount)
        .store_slice(dedust_vault_address) ;; DeDust vault address
        .store_slice(user_address)
        .store_uint(0, 1)
        .store_coins(forward_fee)
        .store_maybe_ref(forward_payload)
        .end_cell();
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jetton_wallet_address)
        .store_coins(gas)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)
        .store_maybe_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}

() send_excesses(int query_id, slice to_address, int value, int mode) impure {
    if (value > min_excesses()) {
        cell msg = begin_cell()
            .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
            .store_slice(to_address)
            .store_coins(value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(op::excesses(), 32)
            .store_uint(query_id, 64)
            .end_cell();
        send_raw_message(msg, mode);
    }
}

;; Function to accumulate excess gas
() accumulate_excess(int query_id, slice user_address, int value) impure {
    if (value <= min_excesses()) {
        return ();
    }
    
    ;; Check if we already have accumulated excess for this query_id
    (cell dict_value, int found) = storage::accumulated_excesses.udict_get_ref?(64, query_id);
    int accumulated_value = 0;
    
    if (found) {
        slice ds = dict_value.begin_parse();
        slice stored_address = ds~load_msg_addr();
        accumulated_value = ds~load_coins();
        
        ;; Safety check: if different user addresses for the same query_id
        if (~ equal_slices(stored_address, user_address)) {
            ;; This is a rare case - we'll send the existing excess and start fresh
            send_excesses(query_id, stored_address, accumulated_value, 1);
            accumulated_value = 0;
        }
    }
    
    ;; Add the new excess to accumulated value
    accumulated_value += value;
    
    ;; Store the updated accumulated value
    cell new_dict_value = begin_cell()
        .store_slice(user_address)
        .store_coins(accumulated_value)
        .end_cell();
    
    storage::accumulated_excesses~udict_set_ref(64, query_id, new_dict_value);
}

;; Function to send accumulated excess gas for a specific query_id
() send_accumulated_excess(int query_id) impure {
    (cell dict_value, int found) = storage::accumulated_excesses.udict_get_ref?(64, query_id);
    
    if (found) {
        slice ds = dict_value.begin_parse();
        slice user_address = ds~load_msg_addr();
        int excess_value = ds~load_coins();
        
        ;; Send accumulated excess if above minimum
        if (excess_value > min_excesses()) {
            send_excesses(query_id, user_address, excess_value, 1); ;; mode 1 to pay transfer fee separately
        }
        
        ;; Remove from dictionary
        storage::accumulated_excesses~udict_delete?(64, query_id);
    }
}