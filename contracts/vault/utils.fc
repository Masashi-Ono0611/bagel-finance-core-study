;; 6905(computational_gas_price) * 1000(cur_gas_price) = 6905000
;; ceil(6905000) = 10000000 ~= 0.01 TON
int provide_address_gas_consumption() asm "10000000 PUSHINT";

int min_excesses() asm "1000000 PUSHINT";
int gas_deposit(int num_baskets) inline {
    return num_baskets * 3200000 + 1400000;
}
int gas_transfer_notification() asm "10000000 PUSHINT";
int gas_transfer_notification_complete(int num_baskets) inline {
    return num_baskets * 2000000 + 2500000;
}
int gas_burn_notification(int num_baskets) inline {
    return num_baskets * 2100000 + 4000000;
}

;; 超過ガス返還処理用の一定額を計算
int gas_excesses() asm "10000000 PUSHINT";

;; 超過ガスを累積する
() accumulate_excess_gas(int excess_amount) impure {
    storage::accumulated_gas += excess_amount;
}

;; 累積したガスを送信する
() send_accumulated_gas(int query_id, slice user_address) impure {
    ;; 累積ガスから処理コスト分を差し引く
    int send_amount = storage::accumulated_gas - gas_excesses();
    if (send_amount < min_excesses()) {
        return ();
    }
    
    ;; 送信前に累積ガスをリセット
    storage::accumulated_gas = 0;
    
    ;; メッセージ作成と送信
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(user_address)
        .store_coins(send_amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(op::excesses_without_accumulated(), 32)
        .store_uint(query_id, 64)
        .end_cell();
    
    send_raw_message(msg, 2);
}

;; 超過ガスを直接返還する（累積なし）
() send_excesses(int query_id, slice address, int amount, int mode) impure {
    if (amount < min_excesses()) {
        return ();
    }
    
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(address)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(op::excesses_without_accumulated(), 32)
        .store_uint(query_id, 64)
        .end_cell();
    
    send_raw_message(msg, mode);
}



() mint_tokens(slice to_address, cell jetton_wallet_code, int amount, cell master_msg) impure {
    cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);
    slice to_wallet_address = calculate_jetton_wallet_address(state_init);
    var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(to_wallet_address)
            .store_coins(amount)
            .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
            .store_ref(state_init)
            .store_ref(master_msg);
    send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
}

slice addr_none() asm "b{00} PUSHSLICE";

;; DEXタイプの定数
int DEX_TYPE_DEDUST() asm "0 PUSHINT";
int DEX_TYPE_STONFI() asm "1 PUSHINT";

;; DEX TONスワップ関数（汎用化）
() swap_dex_ton (
    int query_id,
    int swap_amount,
    int gas,
    slice dex_address, ;; DeDustの場合はdex_pool_address、StonFiの場合はdex_router_address
    slice user_address,
    int dex_type
) impure {
    cell custom_payload = begin_cell()
        .store_slice(user_address)
        .end_cell();
    
    cell swap_params = null();
    cell body = null();
    
    if (dex_type == DEX_TYPE_DEDUST()) {
        ;; DeDust用のパラメータ生成
        swap_params = begin_cell()
            .store_uint(now() + 5 * 60, 32) ;; deadline:Timestamp
            .store_slice(my_address()) ;; recipient_addr:MsgAddressInt
            .store_slice(addr_none()) ;; referral_addr:MsgAddress
            .store_maybe_ref(custom_payload) ;; fulfill_payload:(Maybe ^Cell)
            .store_maybe_ref(null()) ;; reject_payload:(Maybe ^Cell)
            .end_cell();
            
        body = begin_cell()
            .store_uint(op::dedust_ton_swap(), 32)
            .store_uint(query_id, 64) ;; query_id:int64
            ;; _:SwapStep
            .store_coins(swap_amount)
            .store_slice(dex_address) ;; pool_addr:MsgAddressInt
            .store_uint(0, 1) ;; kind:SwapKind
            .store_coins(0) ;; limit:Coins
            .store_maybe_ref(null()) ;; next
            .store_ref(swap_params)
            .end_cell();
    } else {
        ;; Stonfi用のパラメータ生成
        swap_params = begin_cell()
            .store_uint(now() + 5 * 60, 32) ;; deadline:Timestamp
            .store_slice(my_address()) ;; recipient_addr:MsgAddressInt
            .store_slice(addr_none()) ;; referral_addr:MsgAddress
            .store_maybe_ref(custom_payload) ;; fulfill_payload:(Maybe ^Cell)
            .store_maybe_ref(null()) ;; reject_payload:(Maybe ^Cell)
            .end_cell();
            
        body = begin_cell()
            .store_uint(op::stonfi_ton_swap(), 32)
            .store_uint(query_id, 64) ;; query_id:int64
            ;; StonFiのパラメータ構造
            .store_coins(swap_amount)
            .store_slice(dex_address) ;; router_address:MsgAddressInt
            .store_uint(0, 1) ;; kind:SwapKind
            .store_coins(0) ;; limit:Coins
            .store_maybe_ref(null()) ;; next
            .store_ref(swap_params)
            .end_cell();
    }
    
    ;; 送信先アドレスをDEXタイプに応じて選択
    ;; StonFiの場合はdex_router_addressに直接送信
    ;; DeDustの場合はstorage::dex_ton_vault_addressに送信
    slice target_address = dex_type == DEX_TYPE_STONFI() ? dex_address : storage::dex_ton_vault_address;
    
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(target_address)
        .store_coins(swap_amount + gas)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)
        .store_maybe_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}



() mint_index(
    int query_id,
    slice to_address,
    cell jetton_wallet_code,
    int gas,
    int mint_amount
) impure {
    cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);
    slice to_wallet_address = calculate_jetton_wallet_address(state_init);
    cell body = begin_cell()
        .store_uint(op::internal_transfer(), 32)
        .store_uint(query_id, 64)
        .store_coins(mint_amount)
        .store_slice(my_address())
        .store_slice(to_address)
        .store_coins(0)
        .store_uint(0, 1)
        .end_cell();
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to_wallet_address)
        .store_coins(gas)
        .store_uint(7, 107)
        .store_ref(state_init)
        .store_maybe_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}

() send_jetton(
    int query_id,
    slice jetton_wallet_address,
    int gas,
    int jetton_amount,
    slice to_address
) impure {
    cell body = begin_cell()
        .store_uint(op::transfer(), 32)
        .store_uint(query_id, 64)
        .store_coins(jetton_amount)
        .store_slice(to_address)
        .store_slice(to_address)
        .store_uint(0, 1)
        .store_coins(0)
        .store_uint(0, 1)
        .end_cell();
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jetton_wallet_address)
        .store_coins(gas)
        .store_uint(1, 107)
        .store_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}

;; DEX Jettonスワップ関数（汎用化）
() swap_dex_jetton (
    int query_id,
    slice jetton_wallet_address,
    int gas,
    int swap_amount,
    slice dex_vault_address,
    int forward_fee,
    slice dex_pool_address,
    slice user_address,
    int dex_type
) impure {
    cell swap_params = null();
    cell forward_payload = null();
    
    if (dex_type == DEX_TYPE_DEDUST()) {
        ;; DeDust用のパラメータ生成
        swap_params = begin_cell()
            .store_uint(now() + 60 * 5, 32) ;; deadline:Timestamp
            .store_slice(user_address) ;; recipient_addr:MsgAddressInt
            .store_slice(addr_none()) ;; referral_addr:MsgAddress
            .store_maybe_ref(null()) ;; fulfill_payload:(Maybe ^Cell)
            .store_maybe_ref(null()) ;; reject_payload:(Maybe ^Cell)
            .end_cell();
            
        forward_payload = begin_cell()
            .store_uint(op::dedust_jetton_swap(), 32)
            .store_slice(dex_pool_address) ;; pool_addr:MsgAddressInt
            .store_uint(0, 1) ;; kind:SwapKind
            .store_coins(0) ;; limit:Coins
            .store_maybe_ref(null()) ;; next
            .store_ref(swap_params)
            .end_cell();
    } else {
        ;; Stonfi V1用のパラメータ生成
        swap_params = begin_cell()
            .store_uint(now() + 60 * 5, 32) ;; deadline:Timestamp - 有効期限（現在時刻+5分）
            .store_slice(user_address) ;; recipient_addr:MsgAddressInt - ユーザーアドレスを受取人に設定
            .store_slice(addr_none()) ;; referral_addr:MsgAddress - リファラルアドレス（なし）
            .store_maybe_ref(null()) ;; fulfill_payload:(Maybe ^Cell) - 成功時ペイロード（なし）
            .store_maybe_ref(null()) ;; reject_payload:(Maybe ^Cell) - 失敗時ペイロード（なし）
            .end_cell();
            
        forward_payload = begin_cell()
            .store_uint(op::stonfi_jetton_swap(), 32) ;; StonFi V1のジェットンスワップオペレーションコード
            .store_slice(dex_pool_address) ;; pool_addr:MsgAddressInt - StonFiのルーターアドレス
            .store_uint(0, 1) ;; kind:SwapKind - スワップの種類（Jetton→TON）
            .store_coins(0) ;; limit:Coins - 最小受け取り量（0=制限なし）
            .store_maybe_ref(null()) ;; next - 次のスワップステップ（なし）
            .store_ref(swap_params) ;; スワップパラメータ
            .end_cell();
    }
    
    cell body = begin_cell()
        .store_uint(op::transfer(), 32)
        .store_uint(query_id, 64)
        .store_coins(swap_amount)
        .store_slice(dex_vault_address) ;; DEX vault address
        .store_slice(user_address)
        .store_uint(0, 1)
        .store_coins(forward_fee)
        .store_maybe_ref(forward_payload)
        .end_cell();
        
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jetton_wallet_address)
        .store_coins(gas)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)
        .store_maybe_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}
