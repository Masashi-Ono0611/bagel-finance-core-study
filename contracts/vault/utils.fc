;; 6905(computational_gas_price) * 1000(cur_gas_price) = 6905000
;; ceil(6905000) = 10000000 ~= 0.01 TON
int provide_address_gas_consumption() asm "10000000 PUSHINT";

int min_excesses() asm "1000000 PUSHINT";
int gas_deposit(int num_baskets) inline {
    return num_baskets * 3200000 + 1400000;
}
int gas_transfer_notification() asm "10000000 PUSHINT";
int gas_transfer_notification_complete(int num_baskets) inline {
    return num_baskets * 2000000 + 2500000;
}
int gas_burn_notification(int num_baskets) inline {
    return num_baskets * 2100000 + 4000000;
}

;; 超過ガス返還処理用の一定額を計算
int gas_excesses() asm "10000000 PUSHINT";

;; Excessメッセージ処理のガス（0.01 TON）
int gas_excess_processing() asm "10000000 PUSHINT";

;; 辞書更新のガス（0.005 TON）
int gas_dict_update() asm "5000000 PUSHINT";

;; ミント処理のガス（0.02 TON）
int gas_mint_processing() asm "20000000 PUSHINT";

;; 超過ガスを累積する
() accumulate_excess_gas(int excess_amount) impure {
    storage::accumulated_gas += excess_amount;
}

;; 累積したガスを送信する
() send_accumulated_gas(int query_id, slice user_address) impure {
    ;; 累積ガスから処理コスト分を差し引く
    int send_amount = storage::accumulated_gas - gas_excesses();
    if (send_amount < min_excesses()) {
        return ();
    }
    ;; コントラクト残高を確認
    var [balance, _] = get_balance();
    if (balance < send_amount + gas_excesses()) {
        ;; 残高不足の場合は送信可能な金額を計算
        send_amount = max(0, balance - gas_excesses() - min_excesses());
        if (send_amount <= 0) {
            return (); ;; 送信可能な金額がない場合は処理終了
        }
    }

    ;; 送信前に累積ガスをリセット
    storage::accumulated_gas = 0;
    save_storage(); ;; ここで変更を保存!!!!!! DeDust完成版としていたFuncでもこれが抜けていた
    
    ;; メッセージ作成と送信
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(user_address)
        .store_coins(send_amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(op::excesses_without_accumulated(), 32)
        .store_uint(query_id, 64)
        .end_cell();
    
    send_raw_message(msg, 2);
}

;; 超過ガスを直接返還する（累積なし）
() send_excesses(int query_id, slice address, int amount, int mode) impure {
    if (amount < min_excesses()) {
        return ();
    }
    
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(address)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(op::excesses_without_accumulated(), 32)
        .store_uint(query_id, 64)
        .end_cell();
    
    send_raw_message(msg, mode);
}



() mint_tokens(slice to_address, cell jetton_wallet_code, int amount, cell master_msg) impure {
    cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);
    slice to_wallet_address = calculate_jetton_wallet_address(state_init);
    var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(to_wallet_address)
            .store_coins(amount)
            .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
            .store_ref(state_init)
            .store_ref(master_msg);
    send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
}

slice addr_none() asm "b{00} PUSHSLICE";

;; DEXタイプの定数
int DEX_TYPE_DEDUST() asm "0 PUSHINT";
int DEX_TYPE_STONFI() asm "1 PUSHINT";

;; DeDust TONスワップ関数
() swap_dedust_ton(
    int query_id,
    int swap_amount,
    int gas,
    slice dex_pool_address,
    slice user_address
) impure {
    ;; ユーザーアドレスを含むカスタムペイロードを作成
    cell custom_payload = begin_cell()
        .store_slice(user_address)
        .end_cell();
    
    ;; DeDustスワップパラメータを生成
    cell swap_params = begin_cell()
        .store_uint(now() + 5 * 60, 32) ;; deadline:Timestamp（5分後）
        .store_slice(my_address()) ;; recipient_addr:MsgAddressInt（Vaultアドレス）
        .store_slice(addr_none()) ;; referral_addr:MsgAddress（リファラルなし）
        .store_maybe_ref(custom_payload) ;; fulfill_payload（成功時のペイロード）
        .store_maybe_ref(null()) ;; reject_payload（失敗時のペイロード - なし）
        .end_cell();
    
    ;; DeDustスワップメッセージ本体を構築
    cell body = begin_cell()
        .store_uint(op::dedust_ton_swap(), 32) ;; DeDustスワップ操作コード
        .store_uint(query_id, 64) ;; クエリID
        .store_coins(swap_amount) ;; スワップ金額
        .store_slice(dex_pool_address) ;; プールアドレス
        .store_uint(0, 1) ;; スワップ種類（0=通常）
        .store_coins(0) ;; 制限金額（0=制限なし）
        .store_maybe_ref(null()) ;; 次のステップ（なし）
        .store_ref(swap_params) ;; スワップパラメータ
        .end_cell();
    
    ;; DeDustの場合は常にdex_ton_vault_addressに送信
    cell msg = begin_cell()
        .store_uint(0x18, 6) ;; 通常の内部メッセージ
        .store_slice(storage::dex_ton_vault_address) ;; 送信先アドレス
        .store_coins(swap_amount + gas) ;; 送金額 + ガス代
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1) ;; 標準ヘッダー（すべて0）
        .store_maybe_ref(body) ;; メッセージ本体
        .end_cell();
    
    ;; メッセージを送信（モード0 = 残高から支払い）
    send_raw_message(msg, 0);
}

;; StonFi TONスワップ関数
() swap_stonfi_ton(
    int query_id,
    int swap_amount,
    int gas,
    slice dex_proxy_ton_address,
    slice user_address,
    slice dex_jetton_wallet_on_router_address  ;; 変更: dexJettonWalletOnRouterAddressを使用
) impure {
    ;; バスケットから取得したdex_jetton_wallet_on_router_addressを直接使用
    ;; デプロイ時にチェックされているので、ここでのチェックは不要
    
    ;; StonfiSwapペイロードを作成
    cell swap_payload = begin_cell()
        .store_uint(op::stonfi_ton_swap(), 32) ;; StonfiSwap操作コード
        .store_slice(dex_jetton_wallet_on_router_address) ;; token_wallet（バスケットから取得したルーター上のJettonウォレットアドレス）
        .store_coins(0) ;; 最小受け取り量（0 = 制限なし）
        .store_slice(my_address()) ;; 受け取りアドレス（Vaultアドレス）
        .store_uint(0, 1) ;; リファラルなし
        .end_cell();
    
    ;; JettonTransferメッセージを構築
    cell body = begin_cell()
        .store_uint(op::transfer(), 32) ;; JettonTransfer操作コード（0xf8a7ea5）
        .store_uint(query_id, 64) ;; 元のクエリIDをそのまま使用
        .store_coins(swap_amount) ;; 送金額（実際のSwap量）
        .store_slice(dex_proxy_ton_address) ;; 送信先（プロキシTONアドレス）
        .store_slice(my_address()) ;; 応答先（Vaultアドレス）
        .store_maybe_ref(null()) ;; カスタムペイロードなし
        .store_coins(gas) ;; フォワードTON量（gasパラメータを使用）
        .store_uint(1, 1) ;; フォワードペイロードあり
        .store_ref(swap_payload) ;; StonfiSwapペイロード
        .end_cell();
    
    ;; StonFiの場合はプロキシTONアドレスに直接送信
    cell msg = begin_cell()
        .store_uint(0x18, 6) ;; 通常の内部メッセージ
        .store_slice(dex_proxy_ton_address) ;; 送信先アドレス
        .store_coins(swap_amount + gas) ;; 送金額 + ガス代
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1) ;; 標準ヘッダー（すべて0）
        .store_maybe_ref(body) ;; メッセージ本体
        .end_cell();
    
    ;; メッセージを送信（モード0 = 残高から支払い）
    send_raw_message(msg, 0);
}

;; DEX TONスワップ関数（汎用化）- DEXタイプに応じて適切な関数を呼び出す
() swap_dex_ton(
    int query_id,
    int swap_amount,
    int gas,
    slice dex_address, ;; DEXタイプに応じて意味が異なる
    slice user_address,
    int dex_type,
    slice jetton_wallet_address, ;; バスケットから取得したjettonWalletAddress
    slice dex_jetton_wallet_on_router_address ;; 追加: StonFi用のルーター上のJettonウォレットアドレス
) impure {
    if (dex_type == DEX_TYPE_DEDUST()) {
        ;; DeDustの場合
        swap_dedust_ton(
            query_id, 
            swap_amount, 
            gas, 
            dex_address, 
            user_address
        );
    } else {
        if (dex_type == DEX_TYPE_STONFI()) {
            ;; StonFiの場合
            swap_stonfi_ton(
                query_id, 
                swap_amount, 
                gas, 
                dex_address, 
                user_address, 
                dex_jetton_wallet_on_router_address ;; 変更: dexJettonWalletOnRouterAddressを使用
            );
        } else {
            ;; 不明なDEXタイプの場合はエラー
            throw(er::unknown_dex_type());
        }
    }
}



() mint_index(
    int query_id,
    slice to_address,
    cell jetton_wallet_code,
    int gas,
    int mint_amount
) impure {
    cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);
    slice to_wallet_address = calculate_jetton_wallet_address(state_init);
    cell body = begin_cell()
        .store_uint(op::internal_transfer(), 32)
        .store_uint(query_id, 64)
        .store_coins(mint_amount)
        .store_slice(my_address())
        .store_slice(to_address)
        .store_coins(0)
        .store_uint(0, 1)
        .end_cell();
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to_wallet_address)
        .store_coins(gas)
        .store_uint(7, 107)
        .store_ref(state_init)
        .store_maybe_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}

() send_jetton(
    int query_id,
    slice jetton_wallet_address,
    int gas,
    int jetton_amount,
    slice to_address
) impure {
    cell body = begin_cell()
        .store_uint(op::transfer(), 32)
        .store_uint(query_id, 64)
        .store_coins(jetton_amount)
        .store_slice(to_address)
        .store_slice(to_address)
        .store_uint(0, 1)
        .store_coins(0)
        .store_uint(0, 1)
        .end_cell();
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jetton_wallet_address)
        .store_coins(gas)
        .store_uint(1, 107)
        .store_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}

;; DeDust Jettonスワップ関数
() swap_dedust_jetton(
    int query_id,
    slice jetton_wallet_address,
    int gas,
    int swap_amount,
    slice dex_vault_address,
    int forward_fee,
    slice dex_pool_address,
    slice user_address
) impure {
    ;; DeDust用のパラメータ生成
    cell swap_params = begin_cell()
        .store_uint(now() + 60 * 5, 32) ;; deadline:Timestamp
        .store_slice(user_address) ;; recipient_addr:MsgAddressInt
        .store_slice(addr_none()) ;; referral_addr:MsgAddress
        .store_maybe_ref(null()) ;; fulfill_payload:(Maybe ^Cell)
        .store_maybe_ref(null()) ;; reject_payload:(Maybe ^Cell)
        .end_cell();
        
    cell forward_payload = begin_cell()
        .store_uint(op::dedust_jetton_swap(), 32)
        .store_slice(dex_pool_address) ;; pool_addr:MsgAddressInt
        .store_uint(0, 1) ;; kind:SwapKind
        .store_coins(0) ;; limit:Coins
        .store_maybe_ref(null()) ;; next
        .store_ref(swap_params)
        .end_cell();
    
    cell body = begin_cell()
        .store_uint(op::transfer(), 32)
        .store_uint(query_id, 64)
        .store_coins(swap_amount)
        .store_slice(dex_vault_address) ;; DEX vault address
        .store_slice(user_address)
        .store_uint(0, 1)
        .store_coins(forward_fee)
        .store_maybe_ref(forward_payload)
        .end_cell();
        
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jetton_wallet_address)
        .store_coins(gas)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)
        .store_maybe_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}

;; StonFi Jettonスワップ関数
() swap_stonfi_jetton(
    int query_id,
    slice jetton_wallet_address,
    int gas,
    int swap_amount,
    slice dex_vault_address, ;; StonfiではプロキシTONアドレス
    int forward_fee,
    slice dex_pool_address, ;; Stonfiではルーターアドレスとして使用
    slice user_address
) impure {
    ;; Stonfi V1用のペイロード生成（成功例のフォーマットに合わせる）
    ;; トランザクションログから確認した正確なペイロード構造
    cell forward_payload = begin_cell()
        .store_uint(op::stonfi_jetton_swap(), 32)  ;; StonfiSwapのオペレーションコード (0x25938561)
        .store_slice(dex_vault_address)  ;; token_wallet - StonfiのプロキシTONアドレス
        .store_coins(1)  ;; min_out - 最小受け取り量（成功例に合わせて1に変更)
        .store_slice(my_address())  ;; to_address - Vaultアドレスを受取人に設定
        .store_slice(addr_none())  ;; referral_address - リファラルアドレス（なし）
        .end_cell();
    
    cell body = begin_cell()
        .store_uint(0x0f8a7ea5, 32)  ;; Jetton Transfer · 0x0f8a7ea5
        .store_uint(query_id, 64)
        .store_coins(swap_amount)
        .store_slice(dex_pool_address) ;; destination : Stonfiルーターアドレス
        .store_slice(my_address()) ;; response_destination Vaultアドレス
        .store_maybe_ref(null()) ;; カスタムペイロードなし custom_payload: null
        .store_coins(125000000) ;; forward_ton_amount
        .store_uint(1, 1) ;; フォワードペイロードあり is_right: true
        .store_maybe_ref(forward_payload)
        .end_cell();
        
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jetton_wallet_address) ;; ジェットンウォレットアドレス
        .store_coins(gas) ;; gas
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)
        .store_maybe_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}

;; DEX Jettonスワップ関数（汎用化）- DEXタイプに応じて適切な関数を呼び出す
() swap_dex_jetton (
    int query_id,
    slice jetton_wallet_address,
    int gas, ;;gas_per_basket
    int swap_amount,
    slice dex_vault_address,
    int forward_fee, ;;GAS_PER_SWAP
    slice dex_pool_address,
    slice user_address,
    int dex_type
) impure {
    if (dex_type == DEX_TYPE_DEDUST()) {
        ;; DeDustの場合
        swap_dedust_jetton(
            query_id,
            jetton_wallet_address,
            gas,
            swap_amount,
            dex_vault_address,
            forward_fee,
            dex_pool_address,
            user_address
        );
    } else {
        if (dex_type == DEX_TYPE_STONFI()) {
            ;; StonFiの場合
            swap_stonfi_jetton(
                query_id,
                jetton_wallet_address,
                gas,
                swap_amount,
                dex_vault_address,
                forward_fee,
                dex_pool_address,
                user_address
            );
        } else {
            ;; 不明なDEXタイプの場合はエラー
            throw(er::unknown_dex_type());
        }
    }
}
