;; 6905(computational_gas_price) * 1000(cur_gas_price) = 6905000
;; ceil(6905000) = 10000000 ~= 0.01 TON
int provide_address_gas_consumption() asm "10000000 PUSHINT";

int min_excesses() asm "1000000 PUSHINT";
int gas_deposit(int num_baskets) inline {
    return num_baskets * 3200000 + 1400000;
}
int gas_transfer_notification() asm "10000000 PUSHINT";
int gas_transfer_notification_complete(int num_baskets) inline {
    return num_baskets * 2000000 + 2500000;
}
int gas_burn_notification(int num_baskets) inline {
    return num_baskets * 2100000 + 4000000;
}

;; 超過ガス返還処理用の一定額を計算
int gas_excesses() asm "10000000 PUSHINT";

;; 超過ガスを累積する
() accumulate_excess_gas(int excess_amount) impure {
    storage::accumulated_gas += excess_amount;
}

;; 累積したガスを送信する
() send_accumulated_gas(int query_id, slice user_address) impure {
    ;; 累積ガスから処理コスト分を差し引く
    int send_amount = storage::accumulated_gas - gas_excesses();
    if (send_amount < min_excesses()) {
        return ();
    }
    
    ;; 送信前に累積ガスをリセット
    storage::accumulated_gas = 0;
    
    ;; メッセージ作成と送信
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(user_address)
        .store_coins(send_amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(op::excesses_without_accumulated(), 32)
        .store_uint(query_id, 64)
        .end_cell();
    
    send_raw_message(msg, 2);
}

;; 超過ガスを直接返還する（累積なし）
() send_excesses(int query_id, slice address, int amount, int mode) impure {
    if (amount < min_excesses()) {
        return ();
    }
    
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(address)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(op::excesses_without_accumulated(), 32)
        .store_uint(query_id, 64)
        .end_cell();
    
    send_raw_message(msg, mode);
}



() mint_tokens(slice to_address, cell jetton_wallet_code, int amount, cell master_msg) impure {
    cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);
    slice to_wallet_address = calculate_jetton_wallet_address(state_init);
    var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(to_wallet_address)
            .store_coins(amount)
            .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
            .store_ref(state_init)
            .store_ref(master_msg);
    send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
}

slice addr_none() asm "b{00} PUSHSLICE";

() swap_dedust_ton (
    int query_id,
    int swap_amount,
    int gas,
    slice dedust_pool_address,
    slice user_address
) impure {
    cell custom_payload = begin_cell()
        .store_slice(user_address)
        .end_cell();
    cell swap_params = begin_cell()
        .store_uint(now() + 5 * 60, 32) ;; deadline:Timestamp
        .store_slice(my_address()) ;; recipient_addr:MsgAddressInt
        .store_slice(addr_none()) ;; referral_addr:MsgAddress
        .store_maybe_ref(custom_payload) ;; fulfill_payload:(Maybe ^Cell)
        .store_maybe_ref(null()) ;; reject_payload:(Maybe ^Cell)
        .end_cell();
    cell body = begin_cell()
        .store_uint(op::dedust_ton_swap(), 32)
        .store_uint(query_id, 64) ;; query_id:int64
        ;; _:SwapStep
        .store_coins(swap_amount)
        .store_slice(dedust_pool_address) ;; pool_addr:MsgAddressInt
        .store_uint(0, 1) ;; kind:SwapKind
        .store_coins(0) ;; limit:Coins
        .store_maybe_ref(null()) ;; next
        .store_ref(swap_params)
        .end_cell();
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(storage::dedust_ton_vault_address)
        .store_coins(swap_amount + gas)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)
        .store_maybe_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}

() mint_index(
    int query_id,
    slice to_address,
    cell jetton_wallet_code,
    int gas,
    int mint_amount
) impure {
    cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);
    slice to_wallet_address = calculate_jetton_wallet_address(state_init);
    cell body = begin_cell()
        .store_uint(op::internal_transfer(), 32)
        .store_uint(query_id, 64)
        .store_coins(mint_amount)
        .store_slice(my_address())
        .store_slice(to_address)
        .store_coins(0)
        .store_uint(0, 1)
        .end_cell();
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to_wallet_address)
        .store_coins(gas)
        .store_uint(7, 107)
        .store_ref(state_init)
        .store_maybe_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}

() send_jetton(
    int query_id,
    slice jetton_wallet_address,
    int gas,
    int jetton_amount,
    slice to_address
) impure {
    cell body = begin_cell()
        .store_uint(op::transfer(), 32)
        .store_uint(query_id, 64)
        .store_coins(jetton_amount)
        .store_slice(to_address)
        .store_slice(to_address)
        .store_uint(0, 1)
        .store_coins(0)
        .store_uint(0, 1)
        .end_cell();
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jetton_wallet_address)
        .store_coins(gas)
        .store_uint(1, 107)
        .store_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}

() swap_dedust_jetton (
    int query_id,
    slice jetton_wallet_address,
    int gas,
    int swap_amount,
    slice dedust_vault_address,
    int forward_fee,
    slice dedust_pool_address,
    slice user_address
) impure {
    cell swap_params = begin_cell()
        .store_uint(now() + 60 * 5, 32) ;; deadline:Timestamp
        .store_slice(user_address) ;; recipient_addr:MsgAddressInt
        .store_slice(addr_none()) ;; referral_addr:MsgAddress
        .store_maybe_ref(null()) ;; fulfill_payload:(Maybe ^Cell)
        .store_maybe_ref(null()) ;; reject_payload:(Maybe ^Cell)
        .end_cell();
    cell forward_payload = begin_cell()
        .store_uint(op::dedust_jetton_swap(), 32)
        .store_slice(dedust_pool_address) ;; pool_addr:MsgAddressInt
        .store_uint(0, 1) ;; kind:SwapKind
        .store_coins(0) ;; limit:Coins
        .store_maybe_ref(null()) ;; next
        .store_ref(swap_params)
        .end_cell();
    cell body = begin_cell()
        .store_uint(op::transfer(), 32)
        .store_uint(query_id, 64)
        .store_coins(swap_amount)
        .store_slice(dedust_vault_address) ;; DeDust vault address
        .store_slice(user_address)
        .store_uint(0, 1)
        .store_coins(forward_fee)
        .store_maybe_ref(forward_payload)
        .end_cell();
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jetton_wallet_address)
        .store_coins(gas)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)
        .store_maybe_ref(body)
        .end_cell();
    send_raw_message(msg, 0);
}